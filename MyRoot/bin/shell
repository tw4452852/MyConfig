#!/usr/bin/env janet

(import spork)

## Globals

(var- cmds @[])
(var- history @{})


## Completion context capture

(def- sym-prefix-peg
  (peg/compile
    ~{:symchar (+ (range "AZ" "az" "09") (set "~+-./_?"))
      :anchor (drop (cmt ($) ,|(= $ 0)))
      :cap (* (+ (> -1 (not :symchar)) :anchor) (* ($) '(some :symchar)))
      :recur (+ :cap (> -1 :recur))
      :main (> -1 :recur)}))

(defn- my-autocomplete-context
  `Given a buffer and a cursor position, extract a string that will be used as context for autocompletion.
  Return a position and substring from the buffer to use for autocompletion.`
  [buf pos]
  (peg/match sym-prefix-peg buf pos))


## Helpers

(defn- in-janet? [s] (string/has-prefix? "(" s))
(defn- like-dir?
  [prefix]
  (or
    (has-value? prefix (chr "/"))
    (find |(string/has-prefix? prefix $) (os/dir ".") false)))
(defn- replace-tide-maybe [s] (string/replace "~" (os/getenv "HOME") s))
(defn- populate-available-cmds
  []
  (def t @{})
  (def paths (string/split ":" (os/getenv "PATH")))
  (loop [p :in paths
         :when (= (os/stat p :mode) :directory)
         e :in (os/dir p)
         :let [abs (spork/path/join p e)]
         :when (= (os/stat abs :mode) :file)]
    (set (t e) true))
  (set cmds (-> t keys sort)))
(def- history-path (spork/path/join (os/getenv "HOME") ".shell_history"))
(defn- load-history
  []
  (set history (-> history-path slurp unmarshal)))
(defn- save-history
  []
  (->> history marshal (spit history-path)))


## Completers

(defn- complete-file
  [prefix]
  (def ret @[])
  (def abs-dirname (-> prefix replace-tide-maybe spork/path/dirname spork/path/abspath))
  (def last-component-prefix (spork/path/basename prefix))
  (def leading (string/slice prefix 0 (- -1 (length last-component-prefix))))
  (each e (os/dir abs-dirname)
    (def suffix (if (= :directory (os/stat (string abs-dirname "/" e) :mode)) "/" ""))
    (when (string/has-prefix? last-component-prefix e) (array/push ret (string leading e suffix))))
  ret)

(defn- complete-command
  [prefix]
  (def ret @[])
  (def has-prefix? (fn [cmd] (string/has-prefix? prefix cmd)))
  (if-let [start-index (find-index has-prefix? cmds)]
    (take-while has-prefix? (array/slice cmds start-index))
    ret))

(defn- complete-command-options
  [prefix line pos]

  (def ret @[])
  (def ps (spork/sh/split (string/slice line 0 pos)))
  (def cmd (spork/path/basename (ps 0)))
  (def opts (-> (spork/sh/exec-slurp "carapace" cmd "export" ;ps) spork/json/decode))
  (each v (opts "values")
    (array/push ret (v "value")))
  ret)

(defn my-autocomplete-options
  "Handler to get available autocomplete options for a given substring."
  [prefix line pos]
  (try
    (cond
      (in-janet? line)
      (spork/getline/default-autocomplete-options prefix)

      (like-dir? prefix)
      (complete-file prefix)

      (= (length prefix) pos)
      (complete-command prefix)

      (complete-command-options prefix line pos))

    ([e f] @[])))


## Hooks

(defn- run-pre-cmd-hooks
  [l]
  (when (os/getenv "TMUX")
    (eprinf "\x1B]133;A\x1B\\") # Tell tmux the prompt location
    (eprinf "\x1B]2;%q\x1B\\" l) # Set panel title
    (eflush)))


## Main loop

(defn- prompt []
  (string (os/cwd) " > "))

(def- gl (spork/getline/make-getline my-autocomplete-context my-autocomplete-options))

(populate-available-cmds)
(if (spork/sh/exists? history-path)
  (load-history)
  (with [_ (spork/sh/make-new-file history-path)]))

(forever
  (def buf @"")
  (def r (gl (prompt) buf))

  (var- l "")
  (cond
    (= :cancel r) # Take advantage of unused :cancel result to trigger fuzzy history finder
    (with [proc (os/spawn ["fzf" "--bind" "alt-c:replace-query" "--bind" "enter:accept-or-print-query" "--header" "<a-c>: Fill query"] :p {:in :pipe :out :pipe})]
      (->> (keys history) (map |(string $ "\n")) string/join (ev/write (proc :in)))
      (let [[out] (ev/gather
                    (ev/read (proc :out) :all)
                    (os/proc-wait proc))]
        (set l (if out (string/trim out) "")))
      (print (prompt) l))

    (= buf r)
    (do
      (set l (string/trim r))
      (when (and
              (not (empty? l))
              (not (string/has-prefix? "#" l))
              (not (has-key? history l)))
        (set (history l) true)
        (ev/spawn (save-history))))

    (assert (string "Unexpected result from getline: " r)))

  (if-not (empty? l)
    (let
      [ps (spork/sh/split l)
       ps0 (replace-tide-maybe (ps 0))]

      (try
        (cond
          (and (= 1 (length ps)) (= :directory (os/stat ps0 :mode))) # cd to it if only directory exists
          (os/cd ps0)

          (in-janet? ps0)
          (do
            (def r (eval-string l))
            (pp r))

          (do
            (run-pre-cmd-hooks l)
            (def ret (spork/sh/exec "bash" "-c" l)) # Delegate to system shell
            (if-not (zero? ret)
              (printf "Error: %d" ret))))

        ([e f]
          (debug/stacktrace f e ""))))))
