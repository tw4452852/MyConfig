#!/usr/bin/env janet

(import spork)

## History server

(defn- history-server
  [started-ch]

  (var history @{})
  (def lock (ev/rwlock))
  (def history-path (spork/path/join (os/getenv "HOME") ".shell_history"))
  (defn load-history
    []
    (set history (-> history-path slurp unmarshal)))
  (defn save-history
    []
    (->> history marshal (spit history-path)))
  (defn add-to-history
    [l]
    (when (and
            (not (empty? l))
            (not (string/has-prefix? "#" l))
            (not (has-key? history l)))
      (set (history l) true)
      (save-history)))

  (def fns
    {:get-all (fn [self]
                (ev/with-rlock lock (keys history)))
     :add-one (fn [self l]
                (ev/with-wlock lock (add-to-history l)))})

  (if (spork/sh/exists? history-path)
    (load-history)
    (with [_ (spork/sh/make-new-file history-path)]))

  (spork/rpc/server fns)
  (ev/give started-ch true)) # Signal server is up

(defn- history-client
  []

  (def [connected c] (protect (spork/rpc/client)))
  (if connected
    c
    (do
      (def started-ch (ev/thread-chan))
      (ev/thread history-server started-ch :n)
      (ev/take started-ch) # Wait server up
      (spork/rpc/client))))


## Completion context capture

(def- sym-prefix-peg
  (peg/compile
    ~{:symchar (+ (range "AZ" "az" "09") (set "~+-./_?@:"))
      :anchor (drop (cmt ($) ,|(= $ 0)))
      :cap (* (+ (> -1 (not :symchar)) :anchor) (* ($) '(some :symchar)))
      :recur (+ :cap (> -1 :recur))
      :main (> -1 :recur)}))

(defn- my-autocomplete-context
  `Given a buffer and a cursor position, extract a string that will be used as context for autocompletion.
  Return a position and substring from the buffer to use for autocompletion.`
  [buf pos]
  (peg/match sym-prefix-peg buf pos))


## Helpers

(defn- in-janet? [s] (string/has-prefix? "(" s))
(defn- replace-tide-maybe [s] (string/replace "~" (os/getenv "HOME") s))
(defdyn *cmds* "commands found in PATH")
(defn- populate-available-cmds
  []
  (def t @{})
  (def paths (string/split ":" (os/getenv "PATH")))
  (loop [p :in paths
         :when (= (os/stat p :mode) :directory)
         e :in (os/dir p)
         :let [abs (spork/path/join p e)]
         :when (= (os/stat abs :mode) :file)]
    (set (t e) true))
  (setdyn *cmds* (-> t keys sort)))


## Completers

(defn- complete-file
  [ret prefix]
  (var found false)
  (try
    (do
      (def abs-dirname (-> prefix replace-tide-maybe spork/path/dirname spork/path/abspath))
      (def last-component-prefix (spork/path/basename prefix))
      (def leading (string/slice prefix 0 (- -1 (length last-component-prefix))))
      (each e (os/dir abs-dirname)
        (def suffix (if (= :directory (os/stat (string abs-dirname "/" e) :mode)) "/" ""))
        (when (string/has-prefix? last-component-prefix e)
          (set found true)
          (array/push ret (string leading e suffix)))))
    ([e f] (debug/stacktrace f e "")))
  found)

(defn- complete-command
  [ret prefix]
  (var found false)
  (def cmds (dyn *cmds*))
  (defn has-prefix? [cmd] (string/has-prefix? prefix cmd))
  (when-let [start-index (find-index has-prefix? cmds)]
    (def candidates (take-while has-prefix? (array/slice cmds start-index)))
    (array/concat ret candidates)
    (set found true))
  found)

(defn- complete-command-options
  [ret prefix line pos]

  (def- specific-completors
    {"jj" (fn :jj-clap-completer [cmd args]
            (assert (= cmd "jj"))
            (def output
              (spork/sh/exec-slurp "env" "_CLAP_IFS=\n" "COMPLETE=elvish" (string "_CLAP_COMPLETE_INDEX=" (length args)) "jj" "--" "jj" ;args))
            (if (empty? output)
              @[]
              (string/split "\n" output)))})

  (defn- default-completer
    [cmd args]
    (def [success opts] (protect (-> (spork/sh/exec-slurp "carapace" cmd "export" cmd ;args) spork/json/decode))) # possible error is expected
    (if success (map |($ "value") (opts "values")) @[]))

  (var found false)
  (try
    (do
      (def ps (spork/sh/split (string/slice line 0 pos)))
      (def cmd (spork/path/basename (ps 0)))
      (def args (slice ps 1))
      (def candidates ((get specific-completors cmd default-completer) cmd args))
      (unless (empty? candidates)
        (set found true)
        (array/concat ret candidates)))
    ([e f] (debug/stacktrace f e "")))
  found)

(defn my-autocomplete-options
  "Handler to get available autocomplete options for a given substring."
  [prefix line pos]
  (try
    (if (in-janet? line)
      (spork/getline/default-autocomplete-options prefix)
      (do
        (def ret @[])
        (or
          (if (= (length prefix) pos) (complete-command ret prefix) false) # Only do cmd completion when only ourself
          (complete-command-options ret prefix line pos)
          (complete-file ret prefix))
        ret))

    ([e f] (debug/stacktrace f e "") @[])))


## Hooks

(defn- run-pre-cmd-hooks
  [l]
  (when (os/getenv "TMUX")
    (eprinf "\x1B]133;A\x1B\\") # Tell tmux the prompt location
    (eprinf "\x1B]2;%q\x1B\\" l) # Set panel title
    (eflush)))


## Main loop
(defn- sig_nop_handler [])
(defn- prompt []
  (string (os/cwd) " > "))

(defn- main-loop []
  (def gl (spork/getline/make-getline my-autocomplete-context my-autocomplete-options))

  (with [c (history-client)]
    (os/sigaction :int sig_nop_handler) # Ignore Ctrl-C
    (populate-available-cmds)
    (forever
      (def buf @"")
      (def r (gl (prompt) buf))

      (var- l "")
      (cond
        (= :cancel r) # Take advantage of unused :cancel result to trigger fuzzy history finder
        (with [proc (os/spawn ["fzf" "--wrap" "--bind" "alt-c:replace-query" "--bind" "enter:accept-or-print-query" "--header" "<a-c>: Fill query"] :p {:in :pipe :out :pipe})]
          (->> (:get-all c) (map |(string $ "\n")) string/join (ev/write (proc :in)))
          (let [[out] (ev/gather
                        (ev/read (proc :out) :all)
                        (os/proc-wait proc))]
            (set l (if out (string/trim out) "")))
          (print (prompt) l))

        (= buf r)
        (set l (string/trim r))

        (assert (string "Unexpected result from getline: " r)))

      (if-not (empty? l)
        (let
          [args (spork/sh/split l)
           arg0 (replace-tide-maybe (args 0))]

          (try
            (cond
              (in-janet? arg0)
              (do
                (def r (eval-string l))
                (pp r))

              (= "cd" arg0)
              (do
                (def abs_path (-> (or (get args 1) "~") replace-tide-maybe spork/path/abspath))
                (os/cd abs_path)
                (:add-one c (string "cd " abs_path)))

              (do
                (run-pre-cmd-hooks l)
                (def ret (spork/sh/exec "bash" "-c" l)) # Delegate to bash
                (if (zero? ret)
                  (:add-one c l) # Only add successful command to avoid duplications
                  (printf "Error: %d" ret))))

            ([e f]
              (debug/stacktrace f e ""))))))))


(defn main [&] (main-loop))
