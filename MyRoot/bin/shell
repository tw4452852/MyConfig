#!/usr/bin/env janet

(import spork)

## History server

(defn- history-server
  [started-ch]

  (var history @{})
  (def history-path (spork/path/join (os/getenv "HOME") ".shell_history"))
  (defn load-history
    []
    (set history (-> history-path slurp unmarshal)))
  (defn save-history
    []
    (->> history marshal (spit history-path)))
  (defn add-to-history
    [l]
    (when (and
            (not (empty? l))
            (not (string/has-prefix? "#" l))
            (not (has-key? history l)))
      (set (history l) true)
      (ev/spawn (save-history))))

  (def fns
    {:get-all (fn [self]
                (keys history))
     :add-one (fn [self l]
                (add-to-history l))})

  (if (spork/sh/exists? history-path)
    (load-history)
    (with [_ (spork/sh/make-new-file history-path)]))

  (spork/rpc/server fns)
  (ev/give started-ch true)) # Signal server is up

(defn- history-client
  []

  (def [connected c] (protect (spork/rpc/client)))
  (if connected
    c
    (do
      (def started-ch (ev/thread-chan))
      (ev/thread history-server started-ch :n)
      (ev/take started-ch) # Wait server up
      (spork/rpc/client))))


## Client Globals

(var- cmds @[])

## Completion context capture

(def- sym-prefix-peg
  (peg/compile
    ~{:symchar (+ (range "AZ" "az" "09") (set "~+-./_?"))
      :anchor (drop (cmt ($) ,|(= $ 0)))
      :cap (* (+ (> -1 (not :symchar)) :anchor) (* ($) '(some :symchar)))
      :recur (+ :cap (> -1 :recur))
      :main (> -1 :recur)}))

(defn- my-autocomplete-context
  `Given a buffer and a cursor position, extract a string that will be used as context for autocompletion.
  Return a position and substring from the buffer to use for autocompletion.`
  [buf pos]
  (peg/match sym-prefix-peg buf pos))


## Helpers

(defn- in-janet? [s] (string/has-prefix? "(" s))
(defn- replace-tide-maybe [s] (string/replace "~" (os/getenv "HOME") s))
(defn- populate-available-cmds
  []
  (def t @{})
  (def paths (string/split ":" (os/getenv "PATH")))
  (loop [p :in paths
         :when (= (os/stat p :mode) :directory)
         e :in (os/dir p)
         :let [abs (spork/path/join p e)]
         :when (= (os/stat abs :mode) :file)]
    (set (t e) true))
  (set cmds (-> t keys sort)))


## Completers

(defn- complete-file
  [prefix]
  (def ret @[])
  (def abs-dirname (-> prefix replace-tide-maybe spork/path/dirname spork/path/abspath))
  (def last-component-prefix (spork/path/basename prefix))
  (def leading (string/slice prefix 0 (- -1 (length last-component-prefix))))
  (each e (os/dir abs-dirname)
    (def suffix (if (= :directory (os/stat (string abs-dirname "/" e) :mode)) "/" ""))
    (when (string/has-prefix? last-component-prefix e) (array/push ret (string leading e suffix))))
  ret)

(defn- complete-command
  [prefix]
  (def ret @[])
  (def has-prefix? (fn [cmd] (string/has-prefix? prefix cmd)))
  (if-let [start-index (find-index has-prefix? cmds)]
    (take-while has-prefix? (array/slice cmds start-index))
    ret))

(defn- complete-command-options
  [prefix line pos]

  (def ret @[])
  (def ps (spork/sh/split (string/slice line 0 pos)))
  (def cmd (spork/path/basename (ps 0)))
  (def opts (-> (spork/sh/exec-slurp "carapace" cmd "export" ;ps) spork/json/decode))
  (each v (opts "values")
    (array/push ret (v "value")))
  ret)

(defn my-autocomplete-options
  "Handler to get available autocomplete options for a given substring."
  [prefix line pos]
  (try
    (cond
      (in-janet? line)
      (spork/getline/default-autocomplete-options prefix)

      (= (length prefix) pos)
      (complete-command prefix)

      (do
        (def [success ret] (protect (complete-command-options prefix line pos)))
        (if (and success (not (empty? ret)))
          ret
          (complete-file prefix))))

    ([e f] @[])))


## Hooks

(defn- run-pre-cmd-hooks
  [l]
  (when (os/getenv "TMUX")
    (eprinf "\x1B]133;A\x1B\\") # Tell tmux the prompt location
    (eprinf "\x1B]2;%q\x1B\\" l) # Set panel title
    (eflush)))


## Main loop

(defn- sig_nop_handler [])

(defn- prompt []
  (string (os/cwd) " > "))

(def- gl (spork/getline/make-getline my-autocomplete-context my-autocomplete-options))

(with [c (history-client)]
  (os/sigaction :int sig_nop_handler) # Ignore Ctrl-C
  (populate-available-cmds)
  (forever
    (def buf @"")
    (def r (gl (prompt) buf))

    (var- l "")
    (cond
      (= :cancel r) # Take advantage of unused :cancel result to trigger fuzzy history finder
      (with [proc (os/spawn ["fzf" "--bind" "alt-c:replace-query" "--bind" "enter:accept-or-print-query" "--header" "<a-c>: Fill query"] :p {:in :pipe :out :pipe})]
        (->> (:get-all c) (map |(string $ "\n")) string/join (ev/write (proc :in)))
        (let [[out] (ev/gather
                      (ev/read (proc :out) :all)
                      (os/proc-wait proc))]
          (set l (if out (string/trim out) "")))
        (print (prompt) l))

      (= buf r)
      (set l (string/trim r))

      (assert (string "Unexpected result from getline: " r)))

    (if-not (empty? l)
      (let
        [rps (spork/sh/split l)
         ps (if (= "cd" (rps 0)) (slice rps 1) rps) # Skip the first "cd" to adapt to the following cd case
         ps0 (replace-tide-maybe (ps 0))]

        (try
          (cond
            (in-janet? ps0)
            (do
              (def r (eval-string l))
              (pp r))

            (and (= 1 (length ps)) (= :directory (os/stat ps0 :mode))) # cd to it if only directory exists
            (do
              (:add-one c (spork/path/abspath ps0)) # Only add absolutive path to avoid duplications
              (os/cd ps0))

            (do
              (run-pre-cmd-hooks l)
              (def ret (spork/sh/exec "bash" "-c" l)) # Delegate to bash
              (if (zero? ret)
                (:add-one c l) # Only add successful command to avoid duplications
                (printf "Error: %d" ret))))

          ([e f]
            (debug/stacktrace f e "")))))))
