#!/usr/bin/env elvish

use flag
use os
use re
use str

var zig = (external zig)
if (has-env ZIG) {
	set zig = (external $E:ZIG)
}
var m = (re:find &max=1 '.*global_cache_dir.*"(.*)".*' ($zig env|slurp))
var global_cache_dir = $m[groups][1][text]
var fetched = [&]
var content = '
const std = @import("std");
pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const gpa = arena.allocator();
    var writer = std.fs.File.stdout().writer(&.{});
    const stdout = &writer.interface;

    const zon_file = try std.fs.cwd().openFile(std.mem.span(std.os.argv[1]), .{});
    defer zon_file.close();
    var buf: [1024]u8 = undefined;
    var file_reader: std.fs.File.Reader = zon_file.reader(&buf);
    const zon_source = try std.zig.readSourceFileToEndAlloc(
        gpa,
        &file_reader,
    );
    defer gpa.free(zon_source);

    var tree = try std.zig.Ast.parse(gpa, zon_source, .zon);
    defer tree.deinit(gpa);

    const zoir = try std.zig.ZonGen.generate(gpa, tree, .{});
    const root_idx: std.zig.Zoir.Node.Index = .root;
    const root_node = root_idx.get(zoir);
    const dependencies_idx: std.zig.Zoir.Node.Index = deps: {
        for (root_node.struct_literal.names, 0..) |name, i| {
            if (std.mem.eql(u8, name.get(zoir), "dependencies")) {
                break :deps root_node.struct_literal.vals.at(@intCast(i));
            }
        } else {
            try stdout.writeAll("{}\n");
            return;
        }
    };
    try stdout.writeAll("{\n");
    const dependencies_node = dependencies_idx.get(zoir);
    if (dependencies_node == .struct_literal) for (dependencies_node.struct_literal.names, 0..) |name, i| {
        const dep_idx = dependencies_node.struct_literal.vals.at(@intCast(i));
        const dep_node = dep_idx.get(zoir);
        try stdout.print("{s}\"{s}\": {{", .{ if (i != 0) "," else "", name.get(zoir) });
        for (dep_node.struct_literal.names, 0..) |field_name, fi| {
            const field_idx = dep_node.struct_literal.vals.at(@intCast(fi));
            const field_node = field_idx.get(zoir);
            const attr_name = field_name.get(zoir);

            if (std.mem.eql(u8, attr_name, "url") or std.mem.eql(u8, attr_name, "path") or std.mem.eql(u8, attr_name, "hash")) {
                try stdout.print("{s}\"{s}\": \"{s}\"", .{ if (fi != 0) "," else "", attr_name, field_node.string_literal });
            }
        }
        try stdout.writeAll("}");
    };
    try stdout.writeAll("\n}");
}
'

var project_dir = /tmp/zig_fetch
var bin = $project_dir/main
var src = $project_dir/main.zig
fn jit {
  mkdir -p $project_dir
  tmp pwd = $project_dir
  var need_build = $true
  if (and (os:exists $src) (==s $content (cat $src | slurp))) {
    set need_build = $false
  }
  if $need_build {
    put "Building binary..."
    print $content > $src
    $zig build-exe $src
  }
}

fn download {|&expected_hash="" url|
  # Convert git+https of github to commit tar.gz
  if (str:has-prefix $url 'git+https://github.com') {
    var m = (re:find '^git\+https://(.*)#(.*)$' $url)
    set url = 'https://'$m[groups][1][text]'/archive/'$m[groups][2][text]'.tar.gz'
  }
  
  var tmpdir = (os:temp-dir 'zig_fetch-*')
  defer { os:remove-all $tmpdir }
  curl -L -O --output-dir $tmpdir $url
  var hash = ($zig fetch --debug-hash $tmpdir/* | tail -n 1)
  if (and (!=s $expected_hash "") (!=s $hash $expected_hash)) {
    fail "Expected: "$expected_hash" but got: "$hash
  }
  echo $hash
}

fn do_fetch {|&zon="build.zig.zon" &f=$false &name="main" &level=0|
  var m = ($bin $zon | from-json)
  var ident = (str:join '' [(repeat $level ' ')])
  echo $ident$name' depends on:'
  for k [(keys $m)] {
    var expected_hash = "undefined"
    if (has-key $m[$k] hash) {
      set expected_hash = $m[$k][hash]
    } elif (has-key $m[$k] path) {
      set expected_hash = ($zig fetch --debug-hash $m[$k][path] | tail -n 1)
    } else {
      fail "Neither path nor hash has been found"
    }

    if (has-key $fetched $expected_hash) {
      echo $ident$k": fetched"
      continue
    } elif (and (not $f) (os:exists $global_cache_dir/p/$expected_hash)) {
      echo $ident$k": Found in cache: "$expected_hash
    } else {
      echo $ident$k": Fetching from "$m[$k][url]
      if (has-key $m[$k] url) {
        download &expected_hash=$expected_hash $m[$k][url]
      } else {
        fail "Neither url nor path has been found"
      }
    }

    set fetched[$expected_hash] = ''

    var dep_zon = $global_cache_dir/p/$expected_hash/build.zig.zon
    if (os:exists $dep_zon) {
      do_fetch &zon=$dep_zon &f=$f &name=$k &level=(+ $level 1)
    }
  }
}


jit

if (== 1 (count $args)) {
  download $args[0]
} else {
  flag:call $do_fetch~ $args
}
