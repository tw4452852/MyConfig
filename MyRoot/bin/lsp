#!/home/tw/go/bin/elvish
use file
use str
use path

# pipe between input thread(writer), file tracking thread(writer) and server thread(reader)
var p = (file:pipe)
var wlock = $false
fn lock {
  while $wlock { nop }
  set wlock = $true
}
fn unlock {
  set wlock = $false
}

var content = (put [&jsonrpc=2.0 &id=(num 1) &method=initialize &params=[
  &rootUri=file://$pwd
  &capabilities=[
    &general=[
      &positionEncodings=[utf-8]
    ]
  ]
]] | to-json)
put "-------------> main thread send: "$content
printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
set content = (put [&jsonrpc=2.0 &method=initialized &params=[&]] | to-json)
put "-------------> main thread send: "$content
printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p

var mnt = '/tmp/acme'
var winid
var winname = (echo $pwd | 9 tr .@ _)/+LSP
var excepts = [&]
fn add_exception {|p|
  set excepts[$p] = $nil
}
fn del_exception {|p|
  del excepts[$p]
}

fn track_look_loop {
  tmux set-hook -p 'alert-silence['$winid']' 'run "echo delete | 9p write acme/'$winid'/ctl > /dev/null || true"'
  defer { tmux set-hook -pu 'alert-silence['$winid']' }

  9p read acme/$winid/event | acmeevent | eawk {|_l @args|
    #put $args
    try {
      if (and (==s $args[0] event) (str:contains-any $args[2] "xXlL")) {
        if (str:contains-any $args[2] "lL") {
          var file = (str:trim $args[9] "'")
          var last_col = (str:last-index $file :)
          if (!= $last_col -1) {
            set file = $file[..$last_col]
          }
          if (path:is-regular $file) {
            add_exception $file
          }
        }
        echo $args[1]$args[2]$args[3] $args[4] | 9p write acme/$winid/event
      }
    } catch e {
      put $e
    }
  }
}

fn track_tagline_exec {|winid|
  tmux set-hook -p 'alert-silence['$winid']' 'run "echo delete | 9p write acme/'$winid'/ctl > /dev/null || true"'
  defer { tmux set-hook -pu 'alert-silence['$winid']' }

  9p read acme/$winid/event | acmeevent | eawk {|_l @args|
    #put $args
    try {
      if (and (==s $args[0] event) (str:contains-any $args[2] "xXlL")) {
        var flag = $args[7]
        if (and (== $flag 2) (==s $args[2] x)) {
          echo nomenu | 9p write acme/$winid/ctl
          defer { echo menu | 9p write acme/$winid/ctl }

          var tagline = (9p read acme/$winid/tag | slurp)
          var start = (str:index $tagline '|')
          if (== $start -1) {
            continue
          }
          set start = (+ $start 1)
          var origin = $tagline[$start..]
          defer {
            echo cleartag | 9p write acme/$winid/ctl
            print $origin | 9p write acme/$winid/tag
          }

          # prepend ROOT=xxx environment
          var cmd = 'ROOT='$pwd' '$args[9]
          echo cleartag | 9p write acme/$winid/ctl
          echo $cmd | 9p write acme/$winid/tag
          echo Mx$start" "(+ $start (count $cmd)) | 9p write acme/$winid/event
        } else {
          echo $args[1]$args[2]$args[3] $args[4] | 9p write acme/$winid/event
        }
      }
    } catch e {
      put $e
    }
  }
}


fn checkwin {
  try {
    var @parts = (str:fields (9p read acme/index | grep -e $winname))
    set winid = $parts[0]
  } catch e {
    # window not exist, just create one
    set winid = (str:fields (9p read acme/new/ctl) | take 1)
    echo 'name '$winname | 9p write acme/$winid/ctl

    track_look_loop &
  }
}

fn append {|s|
  echo $s | 9p write acme/$winid/body
  echo clean | 9p write acme/$winid/ctl
}

fn endoffset {
  var f = (file:open-output &also-input=$true &if-not-exists=error &if-exists=update $mnt/$winid/addr)
  print '$' > $f
  var @parts = (str:fields (cat < $f))
  put $parts[1]
  file:close $f
}

fn show {|begin end|
  print '#'$begin,'#'$end | 9p write acme/$winid/addr
  echo dot=addr | 9p write acme/$winid/ctl
  echo show | 9p write acme/$winid/ctl
}

fn read_line {|f l|
  var @lines = (cat $f | from-lines)
  put $lines[$l]
}

var log = (file:open $mnt/log)
var id = (num 1)
var cbs = [&]
run-parallel {
  # server thread
  eval (str:join ' ' $args) < $p | while $true {
    var m
    try {
      var n = (read-upto "\n")[16..-2] # get content length
      read-upto "\n" | nop # skip "\r\n"
      set m = (echo (read-bytes $n) | from-json)
    } catch e {
      put 'server thread error:'
      pprint $e
      put 'server thread exit'
      file:close $p[r]
      break
    }

    try {
      $cbs[$m[id]] $m[result]
      del cbs[$m[id]]
    } catch e {
      pprint $m
    }
  }
} {
  # file tracking thread
  var content
  fn handle {|winid cmd @rest|

    # skip if there's no file path
    if (eq $rest []) {
      return
    }
    var name = $rest[0]
    # skip non-regular file
    # TODO: symlink?
    if (not (path:is-regular $name)) {
      return
    }

    # skip the file which is not belonging to us
    if (and (not (str:has-prefix $name $pwd)) (not (has-key $excepts $name))) {
      return
    }

    # skip opened dir
    if (and (==s new $cmd) (path:is-dir $name)) {
      return
    }

    var langid = (try { put (path:ext $name)[1..] } catch e { return })

    fn didOpen {||
      set content = (put [&jsonrpc=2.0 &method=textDocument/didOpen &params=[
        &textDocument=[
          &uri=file://$name
          &languageId=$langid
          &version=(num 0)
          &text=(9p read acme/$winid/body | slurp)
        ]
      ]] | to-json)

      put "-------------> file tracking thread send: "$content
      lock
      printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
      unlock
    }

    if (==s new $cmd) {
      didOpen

      if (has-key $excepts $name) {
        track_tagline_exec $winid &
      }
    } elif (or (==s get $cmd) (==s put $cmd)) {
      # create a new file to avoid it's not been opened
      if (==s put $cmd) {
        didOpen
      }

      set content = (put [&jsonrpc=2.0 &method=textDocument/didChange &params=[
        &textDocument=[
          &uri=file://$name
          &version=(num 0)
        ]
        &contentChanges=[[&text=(9p read acme/$winid/body | slurp)]]
      ]] | to-json)

      put "-------------> file tracking thread send: "$content
      lock
      printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
      unlock
    } elif (==s del $cmd) {
      set content = (put [&jsonrpc=2.0 &method=textDocument/didClose &params=[
        &textDocument=[
          &uri=file://$name
        ]
      ]] | to-json)

      put "-------------> file tracking thread send: "$content
      lock
      printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
      unlock

      del_exception $name
    }

    if (==s put $cmd) {
      set content = (put [&jsonrpc=2.0 &method=textDocument/didSave &params=[
        &textDocument=[
          &uri=file://$name
        ]
      ]] | to-json)

      put "-------------> file tracking thread send: "$content
      lock
      printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
      unlock

      if (eq $E:_lsp_format_on_save 1) {
        set id = (+ $id 1)
        # register a edit callback
        set cbs[$id] = {|m|
          var f = (file:open-output &if-not-exists=error &if-exists=update $mnt/$winid/addr)
          defer {
            file:close $f
          }

          fn apply {|m|
            printf '%d+#%d,%d+#%d'^
              $m[range][start][line] $m[range][start][character]^
              $m[range][end][line] $m[range][end][character]^
            > $f
            print $m[newText] | 9p write acme/$winid/data
          }

          if (==s (kind-of $m) list) {
            var @entries = (order &less-than={|a b|
              if (== $a[range][start][line] $b[range][start][line]) {
                put (< $a[range][start][character] $b[range][start][character])
              } else {
                put (< $a[range][start][line] $b[range][start][line])
              }
            } &reverse=$true $m)
            for entry $entries {
              apply $entry
            }
          } elif (not (is $m $nil)) {
            apply $m
          }
        }

        set content = (put [&jsonrpc=2.0 &id=$id &method=textDocument/formatting &params=[
          &textDocument=[
            &uri=file://$name
          ]
          &options=[
            &tabSize=(num 4)
            &insertSpaces=$false
          ]
        ]] | to-json)

        put "-------------> file tracking thread send: "$content
        lock
        printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
        unlock
      }
    }
  }

  # already openned windows
  9p read acme/index | from-lines | each {|l|
    var @parts = (str:fields $l)
    handle $parts[0] new $parts[5]
  }

  from-lines < $log | each {|l|
    try {
      handle (str:fields $l)
    } catch e {
      put $l
      put 'file tracking thread: error:'
      put $e
      put 'file tracking thread: exit'
      break
    }
  }
} {
  # Input reader thread (also the main thread)
  while $true {
    try {
      var l = (read-line)
      var @parts = (str:fields $l)
      var cmd = $parts[0]
      var file = $parts[1]
      var line = (num $parts[2])
      var char = (num $parts[3])

      put 'recv: '$l
      if (==s $cmd def) {
        if (< (count $parts) 4) {
          put "not enough parameters for definition, skip: "$l
          continue
        }

        set id = (+ $id 1)
        set content = (put [&jsonrpc=2.0 &id=$id &method=textDocument/definition &params=[
          &textDocument=[
            &uri=file://$file
          ]
          &position=[
            &line=$line
            &character=$char
          ]
        ]] | to-json)

        checkwin
        append (printf "\n%s:%d+#%d def: %s" $file $parts[2] $parts[3] (read_line $file $parts[2]) | slurp)
      } elif (==s $cmd ref) {
        if (< (count $parts) 4) {
          put "not enough parameters for reference, skip: "$l
          continue
        }

        set id = (+ $id 1)
        set content = (put [&jsonrpc=2.0 &id=$id &method=textDocument/references &params=[
          &textDocument=[
            &uri=file://$file
          ]
          &position=[
            &line=$line
            &character=$char
          ]
          &context=[
            &includeDeclaration=$true
          ]
        ]] | to-json)

        checkwin
        append (printf "\n%s:%d+#%d refs: %s" $file $parts[2] $parts[3] (read_line $file $parts[2]) | slurp)
      } elif (==s $cmd imp) {
        if (< (count $parts) 4) {
          put "not enough parameters for implementation, skip: "$l
          continue
        }

        set id = (+ $id 1)
        set content = (put [&jsonrpc=2.0 &id=$id &method=textDocument/implementation &params=[
          &textDocument=[
            &uri=file://$file
          ]
          &position=[
            &line=$line
            &character=$char
          ]
        ]] | to-json)

        checkwin
        append (printf "\n%s:%d+#%d impls: %s" $file $parts[2] $parts[3] (read_line $file $parts[2]) | slurp)
      } else {
        put "skip unknown input: "$l
        continue
      }

      # register a display callback
      set cbs[$id] = {|m|
        var count = 0
        var addr
        var begin = (endoffset)
        var file
        if (==s (kind-of $m) list) {
          for entry $m {
            set file = $entry[uri][7..]
            set addr = (printf "%s:%d+#%d,%d+#%d" $file^
              $entry[range][start][line] $entry[range][start][character]^
              $entry[range][end][line] $entry[range][end][character]^
            )
            append (printf "%s %s\n" $addr (read_line $file $entry[range][start][line]))
            set count = (+ $count 1)
          }
        } else {
          set file = $m[uri][7..]
          set addr = (printf "%s:%d+#%d,%d+#%d" $file^
            $m[range][start][line] $m[range][start][character]^
            $m[range][end][line] $m[range][end][character]^
          )
          append (printf "%s %s\n" $addr (read_line $file $m[range][start][line]))
          set count = (+ $count 1)
        }

        # jump to it if there's only one result
        if (== $count 1) {
          add_exception $file
          B $addr
        }

        # make sure the results are visible
        show $begin (endoffset)
      }

      put "-------------> input thread send: "$content
      lock
      printf "Content-Length: %d\r\n\r\n%s" (count $content) $content > $p
      unlock
    } catch e {
      put 'input thread: error:'
      pprint $e
      break
    }
  }

  put 'input thread: exit'
  file:close $p[w] # terminate server thread
  file:close $log # terminate file tracking thread
}
